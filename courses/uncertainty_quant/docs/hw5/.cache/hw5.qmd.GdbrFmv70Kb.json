{
    "cells": [
        {
            "id": "1",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "---\n",
                "title: Homework 5\n",
                "date: 2024-11-14\n",
                "author:\n",
                "  - name: Kevin Silberberg\n",
                "    id: ks\n",
                "    orcid: 0009-0009-4825-1865\n",
                "    email: ksilberb@ucsc.edu\n",
                "    affiliation:\n",
                "      - name: University of California Santa Cruz\n",
                "        city: Santa Cruz\n",
                "        state: CA\n",
                "        href: https://www.ucsc.edu\n",
                "engine: julia-1.11\n",
                "julia:\n",
                "  exeflags: [\"--project=/home/kevinsilberberg/Repos/paxnomada/courses/uncertainty_quant/\"]\n",
                "execute:\n",
                "  daemon: true\n",
                "  cache: true\n",
                "  eval: true\n",
                "  freeze: auto\n",
                "---\n",
                "\n",
                "# Question 1\n",
                "\n",
                "Consider a random variable $\\xi$ with PDF\n",
                "\n",
                "\\begin{equation}\\label{eq-pxi}\n",
                "\tp_{\\xi}(x) =\n",
                "\t\\begin{cases}\n",
                "\t\t\\frac{e^{-x}}{e - e^{-1}} & x \\in [-1, 1] \\\\\n",
                "\t\t0 & \\text{otherwise}\n",
                "\t\\end{cases}\n",
                "\\end{equation}\n",
                "\n",
                "refer to @fig-pdfxi for a plot of the PDF\n",
                "\n",
                "## Part A\n",
                "\n",
                "Use the Stieltjes algorithm to compute the sixth-order generalized polynomial choas basis $$\\{P_0(x), P_1(x), ..., P_6(x)\\}$$ for $\\xi$, i.e. a set of polynomials up to degree 6 that are orthogonal relative to the PDF $\\xi$ given in \\eqref{eq-pxi}.\n",
                "\n",
                "### Solution\n",
                "\n",
                "We know that since the distribution function \\eqref{eq-pxi} is compactly supported, that the solution to the moment problem is unique and exists.\n",
                "\n",
                "Let $c = \\frac{1}{e-e^{-1}}$ the constant in $p_{\\xi}(x)$\n",
                "\n",
                "Following the Stieltjes algorithm, let us compute the first orthogonal polynomial and then we will write a code that computes the first six orthogonal polynomials where\n",
                "\\begin{align}\n",
                "\\mu(x) = ce^{-x}\n",
                "\\end{align}\n",
                "\n",
                "is out weight function.\n",
                "\n",
                "Let $n = 0 \\quad \\pi_0 = 1 \\quad \\pi_{-1} = 0$\n",
                "\n",
                "\\begin{align}\n",
                "\\alpha_0 &= \\frac{\\langle x , 1 \\rangle}{\\langle 1, 1 \\rangle} \\\\\n",
                "&= \\frac{c \\int_{-1}^{1}x e^{-x}dx}{c \\int_{-1}^{1}e^{-x}dx} \\\\\n",
                "&= \\frac{\\left[{-x e^{-x}}_{\\bigg{\\vert}_{-1}^{1}} - \\int_{-1}^{1}-e^{-x}dx\\right]}{\\left[{-e^{-x}}_{\\bigg{\\vert}_{-1}^{1}}\\right] } \\\\\n",
                "&= \\frac{-e^{-1} - e - e^{-1} + e}{-e^{-1} + e} \\\\\n",
                "&= -\\frac{2}{e^2 - 1} \\approx -0.31304\n",
                "\\end{align}\n",
                "\n",
                "Using $\\alpha_0$ let us find the first polynomial $\\pi_1$ using the following formula\n",
                "\n",
                "\\begin{align}\n",
                "\\pi_{n+1}(x) = (x - \\alpha_n)\\pi_n(x) - \\beta_n \\pi_{n-1}(x)\n",
                "\\end{align}\n",
                "\n",
                "\\begin{align}\n",
                "\\pi_1(x) &= (x - \\alpha_0)\\pi_0 - \\beta_0 \\pi_{-1} \\\\\n",
                "&= x + \\frac{2}{e^2 - 1}\n",
                "\\end{align}\n",
                "\n",
                "Let us now write a code that produces any arbitray number of orthogonal polynomials with respect to the weight function."
            ]
        },
        {
            "id": "2",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "using GLMakie\n",
                "using QuadGK\n",
                "using StaticArrays\n",
                "using Statistics\n",
                "\n",
                "# weight function\n",
                "μ(x) = exp(-x) * ^((exp(1.0) - ^(exp(1.0), -1.0)), -1.0)\n",
                "\n",
                "# define an integral using gauss-kronrod quadrature rule\n",
                "integ(x::Function, sup::SVector{2}) = quadgk(x, sup[1], sup[2]; atol=1e-8, rtol=1e-8)[1]\n",
                "\n",
                "# the support of the weight function\n",
                "sup = SVector{2}(-1.0, 1.0)\n",
                "\n",
                "# cumulative trapazoidal rule\n",
                "function cumsumtrap(f::Function, x)\n",
                "    y = f.(x)\n",
                "    N = length(x)\n",
                "    x1 = @view x[1:N-1]\n",
                "    x2 = @view x[2:N]\n",
                "    y1 = @view y[1:N-1]\n",
                "    y2 = @view y[2:N]\n",
                "    integral = cumsum(((x2.-x1).*(y1.+y2))./2.0)\n",
                "    integral ./= integral[end]\n",
                "    return [0; integral]\n",
                "end\n",
                "\n",
                "# CDF inverse sampler\n",
                "function sampleInverseCDF(x::Float64, points::Matrix{Float64})\n",
                "    idx = findfirst(points[:, 1] .> x)\n",
                "    if idx === nothing\n",
                "        p1 = points[end-1, :]\n",
                "        p2 = points[end, :]\n",
                "    elseif idx == 1\n",
                "        p1 = points[1, :]\n",
                "        p2 = points[2, :]\n",
                "    else\n",
                "        p1 = points[idx-1, :]\n",
                "        p2 = points[idx, :]\n",
                "    end\n",
                "    liy(x, p1, p2)\n",
                "end\n",
                "\n",
                "# Linear Interpolator\n",
                "function liy(x::Float64, p1::Vector{Float64}, p2::Vector{Float64})\n",
                "    x1, y1 = p1\n",
                "    x2, y2 = p2\n",
                "    if isapprox(x1, x2, atol = 1e-12)\n",
                "        return (y1 + y2) / 2.0\n",
                "    end\n",
                "    return y1 + (x - x1)*(y2 - y1)/(x2 - x1)\n",
                "end\n",
                "\n",
                "# stieltjes algorithm\n",
                "function stieltjes(μ::Function, N::Int64, sup::SVector{2})\n",
                "    # μ: weight function defining the inner product\n",
                "    # N: number of orthogonal polynomials to compute\n",
                "    # sup: support (integration bounds) of the weight function\n",
                "\n",
                "    M = N + 2  # Extend size to accommodate buffer\n",
                "    n = 2      # Starting index for the recursion\n",
                "\n",
                "    # Initialize orthogonal polynomials (πn) as functions\n",
                "    π = Vector{Function}(undef, M)\n",
                "    π[n-1] = x -> 0.0 * x^0.0  # π₀(x) = 0\n",
                "    π[n] = x -> 1.0 * x^0.0    # π₁(x) = 1\n",
                "\n",
                "    # Initialize coefficient vectors αn and βn\n",
                "    α = Vector{Float64}(undef, M)\n",
                "    β = Vector{Float64}(undef, M)\n",
                "    β[n-1] = 0.0  # β₀ = 0\n",
                "    β[n] = 0.0    # β₁ = 0\n",
                "\n",
                "    # Compute the first α coefficient (α₂)\n",
                "    # α₂ = ⟨xπ₁, π₁⟩ / ⟨π₁, π₁⟩\n",
                "    α[n] = integ(x -> x * π[n](x) * π[n](x) * μ(x), sup) / integ(x -> π[n](x) * π[n](x) * μ(x), sup)\n",
                "\n",
                "    # Compute the next orthogonal polynomial π₂\n",
                "    # π₂(x) = (x - α₁)π₁(x) - β₁π₀(x)\n",
                "    π[n+1] = x -> (x - α[n]) * π[n](x) - β[n] * π[n-1](x)\n",
                "\n",
                "    for n in 3:M-1\n",
                "        α[n] = integ(x -> x * π[n](x) * π[n](x) * μ(x), sup) / integ(x -> π[n](x) * π[n](x) * μ(x), sup)\n",
                "        β[n] = integ(x -> π[n](x) * π[n](x) * μ(x), sup) / integ(x -> π[n-1](x) * π[n-1](x) * μ(x), sup)\n",
                "        π[n+1] = π[n+1] = x -> (x - α[n]) * π[n](x) - β[n] * π[n-1](x)\n",
                "    end\n",
                "    return π\n",
                "end\n",
                "π = stieltjes(μ, 6, sup)"
            ],
            "outputs": [
                {
                    "output_type": "execute_result",
                    "execution_count": 1,
                    "data": {
                        "text/plain": "8-element Vector{Function}:\n #1 (generic function with 1 method)\n #2 (generic function with 1 method)\n #5 (generic function with 1 method)\n #10 (generic function with 1 method)\n #10 (generic function with 1 method)\n #10 (generic function with 1 method)\n #10 (generic function with 1 method)\n #10 (generic function with 1 method)"
                    },
                    "metadata": {
                    }
                }
            ],
            "execution_count": 1
        },
        {
            "id": "3",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "Let us define a function that plots the first polynomial $\\pi_1(x)$ over the numerical result as a validation."
            ]
        },
        {
            "id": "4",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "function validatepione(π::Vector{Function})\n",
                "    π_1(x) = x + (2 / (exp(1)^2 - 1))\n",
                "    xs = LinRange(-1, 1, 1000)\n",
                "    fig = Figure()\n",
                "    ax = Axis(fig[1, 1], title = \"first orthogonal polynomial validation\")\n",
                "    lines!(ax, xs, π_1.(xs), label = \"analytical\")\n",
                "    lines!(ax, xs, π[3].(xs), label = \"numerical\", linestyle = :dash, color = :red)\n",
                "    Legend(fig[1, 2], ax)\n",
                "    save(\"validationpione.png\", fig)\n",
                "end\n",
                "validatepione(π);"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "5",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "![Validation of the stieltjes algorthim: Plot of numerical over analytical solution of the first orthogonal polynomial](validationpione.png)\n",
                "\n",
                "## Part B\n",
                "\n",
                "Veriy that the polynomial basis you obtained in part a is orthogonal, i.e., that the matrix\n",
                "\n",
                "\\begin{equation}\\label{polybasis}\n",
                "\\mathbb{E}\\{P_k(\\xi)P_j(\\xi)\\} = \\int_{-1}^{1} P_k(x)P_j(x)dx\n",
                "\\end{equation}\n",
                "is diagonal.\n",
                "\n",
                "### Solution\n",
                "\n",
                "Let us write a code that computes the Matrix and then plot the matrix using a heatmap to check if it diagonal."
            ]
        },
        {
            "id": "6",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "function isdiagonal(π::Vector{Function}, sup::SVector{2})\n",
                "    A = Matrix{Float64}(undef, 7, 7)\n",
                "    for idx in CartesianIndices(A)\n",
                "        (k, j) = idx.I\n",
                "        ele = integ(x-> π[k+1](x) * π[j+1](x) * μ(x), sup)\n",
                "        A[k, j] = ele < 1e-12 ? 1e-8 : ele\n",
                "    end\n",
                "    fig = Figure()\n",
                "    ax = Axis(fig[1, 1], title = \"heatmap of the diagona matrix\")\n",
                "    heatmap!(ax, log10.(A))\n",
                "    ax.yreversed=true\n",
                "    save(\"heatmapdiagonal.png\", fig)\n",
                "end\n",
                "isdiagonal(π, sup)"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "7",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "![Heatmap showing that the matrix of innerproducts with respect to the weight function of all polynomials generated is diagonal.](heatmapdiagonal.png)\n",
                "\n",
                "Clearly we can see that the matrix is diagonal and thus the polynomial functions are orthogonal with respect to the weight function.\n",
                "\n",
                "## Part C\n",
                "\n",
                "Plot $P_k(x)$ for $k = 0, ..., 6$\n",
                "\n",
                "### Solution\n",
                "\n",
                "Let us define a code that plots all polynomials $P_k(x)$ for $k = 0, ..., 6$"
            ]
        },
        {
            "id": "8",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "function plotpolynomials(π::Vector{Function})\n",
                "    M = size(π)[1]\n",
                "    fig = Figure();display(fig)\n",
                "    ax = Axis(fig[1, 1], title = \"Plot of the set of orthogonal polynomials up to degree 6\")\n",
                "    xs = LinRange(-1.0, 1.0, 1000)\n",
                "    for n in 1:M-1\n",
                "        lines!(ax, xs, π[n+1].(xs), label=\"π_$(n-1)\")\n",
                "    end\n",
                "    Legend(fig[1, 2], ax)\n",
                "    save(\"plotpolynomials.png\", fig)\n",
                "end\n",
                "plotpolynomials(π)"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "9",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "![Plot of polynomials within the support [-1, 1]](plotpolynomials.png)\n",
                "\n",
                "# Question 2\n",
                "\n",
                "Consider the following nonlinear fuction of the random variable $\\xi(\\omega)$ with PDF defined in \\eqref{eq-pxi}\n",
                "\n",
                "\\begin{equation}\\label{eta}\n",
                "\\eta(\\omega) = \\frac{\\xi(\\omega) -1}{2 + 1\\sin{(2\\xi(\\omega))}}\n",
                "\\end{equation}\n",
                "\n",
                "## Part A\n",
                "\n",
                "Compute the PDF of $\\eta$ using the relative frequency approach. To this end, sample 50,000 realizations of $\\xi$ using the inverse CDF approach applied to \\eqref{eq-pxi}, and use such samples to compute samples of $\\eta(\\omega)$.\n",
                "\n",
                "### Solution\n",
                "\n",
                "The following code samples from \\eqref{eq-pxi} 50,000 times using the inverse sampling method previously applied in Homework 1 and 2, then applies the transformation \\eqref{eta}, and finally plots the histogram with 80 bins, normalized so that the PDF integrates to one over the support."
            ]
        },
        {
            "id": "10",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "η(ξ) = (ξ - 1) / (2 + sin(2*ξ))\n",
                "function question2a()\n",
                "    r = LinRange(-1, 1, 1000)\n",
                "    fig = Figure();display(fig)\n",
                "    ax = Axis(fig[1, 1],\n",
                "        title = \"PDF of η(ξ(ω))\")\n",
                "    ys = cumsumtrap(μ, r)\n",
                "    samples = Vector{Float64}(undef, 50000)\n",
                "    for i in eachindex(samples)\n",
                "        samples[i] = η(sampleInverseCDF(rand(), hcat(ys, r)))\n",
                "    end\n",
                "    hist!(ax, samples, bins = 80, normalization = :pdf)\n",
                "    save(\"question2a.png\", fig)\n",
                "    samples\n",
                "end\n",
                "samples = question2a();"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "11",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "![PDF of $\\eta(\\xi(\\omega))$ by sampling 50,000 times via inverse CDF approach and applying the transformation \\eqref{eta}](question2a.png)\n",
                "\n",
                "## Part B\n",
                "\n",
                "Show numerically that the gPC expansion [^2]\n",
                "\n",
                "\\begin{equation}\\label{gpc}\n",
                "\\eta_M(\\omega) = \\sum_{k=0}^{M}a_k P_k(\\xi(\\omega)), \\quad a_k = \\frac{\\mathbb{E}\\{\\eta(\\xi(\\omega))P_k(\\xi(\\omega))\\}}{\\mathbb{E}\\{P_k^2(\\xi(\\omega))\\}}\n",
                "\\end{equation}\n",
                "\n",
                "converges to $\\eta(\\omega)$ in distribution as $M$ increases. To this end, plot the PDF of the random variables $\\eta_M(\\xi(\\omega))$ for $M = 1, 2, 4, 6$ using method of relative frequencies and compare such PDF's with the PDF of $\\eta$ you computed in part a.\n",
                "\n",
                "### Solution"
            ]
        },
        {
            "id": "12",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "function question2b(πn::Vector{Function})\n",
                "    a = Vector{Float64}(undef, 7)\n",
                "    colors = Symbol[:red, :green, :blue, :yellow, :orange, :purple]\n",
                "    # calculate coefficients\n",
                "    for k in eachindex(a)\n",
                "        a[k] = integ(x -> η(x) * πn[k+1](x) * μ(x), sup) / integ(x -> πn[k+1](x) * πn[k+1](x) * μ(x), sup)\n",
                "    end\n",
                "\n",
                "    fig = Figure();display(fig)\n",
                "    ax = Axis(fig[1, 1], title=\"densities of ηM(ξ(ω)) for M = {1, 2, 4, 6}\")\n",
                "    r = LinRange(-1, 1, 1000)\n",
                "    ys = hcat(cumsumtrap(μ, r), r)\n",
                "    for M in SVector{4}(1, 2, 4, 6)\n",
                "        ηM_samples = Vector{Float64}(undef, 50000)\n",
                "        for l in eachindex(ηM_samples)\n",
                "            η_sum = 0.0\n",
                "            ξ = sampleInverseCDF(rand(), ys)\n",
                "            for k in 1:M+1\n",
                "                η_sum+=a[k]*πn[k+1](ξ)\n",
                "            end\n",
                "            ηM_samples[l] = η_sum\n",
                "        end\n",
                "        density!(ax, ηM_samples, color = (colors[M], 0.3), label = \"M = $M\", strokecolor = colors[M], strokewidth = 3, strokearound = true)\n",
                "    end\n",
                "    Legend(fig[1, 2], ax)\n",
                "    save(\"question2b.png\", fig)\n",
                "end\n",
                "question2b(π);"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "13",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "![The PDF ploted using Kernel Density Estimation for values M = {1, 2, 4, 6}](question2b.png)\n",
                "\n",
                "As we can see, the PDF of the random variable $\\eta_M(\\omega)$ converges to the PDF of $\\eta(\\omega)$ as M increases.\n",
                "\n",
                "[^2]: Note that $\\mathbb{E}\\{\\eta(\\xi(\\omega))P_k(\\xi(\\omega))\\}$ can be computed with MC, or with quadrature as \\begin{equation}\\label{four}\\mathbb{E}\\{\\eta(\\xi(\\omega))P_k(\\xi(\\omega))\\}= \\int_{-1}^{1}\\frac{x - 1}{2 + 1 \\sin(2x)}P_k(x)P_\\xi(x)dx\\end{equation}\n",
                "\n",
                "## Part C\n",
                "\n",
                "Compute the mean and variance of $\\eta_6$ and compare it with the mean and variance of $\\eta$. Note that such means and variances can be computed in multiple ways, e.g., by using MC, or by approximating the integral defining the moments of the random variable $\\eta$ using quadrature, e.g., via the trapezoidal rule applied to the integral\n",
                "\n",
                "\\begin{equation}\\label{quadr}\n",
                "\\mathbb{E}\\{\\eta^k\\} = \\int_{-1}^{1} \\left(\\frac{x-1}{2+\\sin(2x)}\\right)^k p_{\\xi}(x)dx\n",
                "\\end{equation}\n",
                "\n",
                "### Solution\n",
                "\n",
                "Let us find the mean and variance of $\\eta$ and $\\eta_6$ by generating 1000 samples of size 1000 and taking the average of the mean and variance for each sample."
            ]
        },
        {
            "id": "14",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "function question2c()\n",
                "    πn = stieltjes(μ, 6, sup)\n",
                "    r = LinRange(-1, 1, 1000)\n",
                "    ys = hcat(cumsumtrap(μ, r), r)\n",
                "    η_samples = Vector{Float64}(undef, 50000)\n",
                "    for i in eachindex(η_samples)\n",
                "        η_samples[i] = η(sampleInverseCDF(rand(), ys))\n",
                "    end\n",
                "    a = Vector{Float64}(undef, 7)\n",
                "    for k in eachindex(a)\n",
                "        a[k] = integ(x -> η(x) * πn[k+1](x) * μ(x), sup) / integ(x -> πn[k+1](x) * πn[k+1](x) * μ(x), sup)\n",
                "    end\n",
                "    η6_samples = Vector{Float64}(undef, 50000)\n",
                "    for l in eachindex(η6_samples)\n",
                "        η_sum = 0.0\n",
                "        ξ = sampleInverseCDF(rand(), ys)\n",
                "        for k in eachindex(a)\n",
                "            η_sum+=a[k]*πn[k+1](ξ)\n",
                "        end\n",
                "        η6_samples[l] = η_sum\n",
                "    end\n",
                "\n",
                "    means = Vector{Float64}(undef, 1000)\n",
                "    variances = Vector{Float64}(undef, 1000)\n",
                "    for i in eachindex(means)\n",
                "        sample = rand(η_samples, 1000)\n",
                "        means[i] = mean(sample)\n",
                "        variances[i] = var(sample)\n",
                "    end\n",
                "    η_mean = mean(means)\n",
                "    η_var = mean(variances)\n",
                "\n",
                "    means = Vector{Float64}(undef, 1000)\n",
                "    variances = Vector{Float64}(undef, 1000)\n",
                "    for i in eachindex(means)\n",
                "        sample = rand(η6_samples, 1000)\n",
                "        means[i] = mean(sample)\n",
                "        variances[i] = var(sample)\n",
                "    end\n",
                "    η6_mean = mean(means)\n",
                "    η6_var = mean(variances)\n",
                "    fig = Figure();display(fig)\n",
                "    ax = Axis(fig[1, 1],\n",
                "        xticks = (1:2, [\"η\", \"η₆\"]),\n",
                "    title = \"mean and variance for η and η_6\")\n",
                "    barplot!(ax, [1, 1, 2, 2], [η_mean, η_var, η6_mean, η6_var],\n",
                "        dodge = [1, 2, 1, 2],\n",
                "        color = [1, 2, 1, 2])\n",
                "    save(\"question2c.png\", fig)\n",
                "end\n",
                "question2c();"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "15",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "![Barplot of the bootstrap mean and variance from MC for $\\eta$ and $\\eta_6$](question2c.png)\n",
                "\n",
                "From the plot we can see the the sample mean and variance for both are almost identical.\n",
                "\n",
                "# Question 3\n",
                "\n",
                "Compute the solution of the following random initial value problem\n",
                "\n",
                "\n",
                "\\begin{equation}\\label{randomivp}\n",
                "\\begin{cases}\n",
                "\t\\frac{dx}{dt} &= -\\xi(\\omega)x + \\cos(4t) \\\\\n",
                "\tx(0) &= 1\n",
                "\\end{cases}\n",
                "\\end{equation}\n",
                "\n",
                "using the stocastic Galerkin method with the gPC basis you obtained in question 1. In particular, use the following gPC expansion of degree 6 for the solution of \\eqref{randomivp}.\n",
                "\n",
                "\\begin{equation}\\label{eight}\n",
                "x(t;\\omega) = \\sum_{k=0}^6 \\hat{x}_k(t)P_k(\\xi(\\omega))\n",
                "\\end{equation}\n",
                "\n",
                "where the gPC modes $\\hat{x}_k(t)$ are to be determined from \\eqref{randomivp}.\n",
                "\n",
                "## Part A\n",
                "\n",
                "Compute the mean and the variance of \\eqref{eight} of $t \\in [0, 3]$.\n",
                "\n",
                "### Solution\n",
                "\n",
                "Let us find the solution of the random initial value problem by using the stocastic Galerkin method and finding the gPC modes by plugging in \\eqref{eight} into \\eqref{randomivp}.\n",
                "\n",
                "\\begin{align}\n",
                "\t\\sum_{k=0}^{6}\\frac{\\partial \\hat{x}_k}{\\partial t}P_k &= -\\xi \\sum_{k=0}^{6}\\hat{x}_k P_k + cos(4t) \\\\\n",
                "\\frac{\\partial \\hat{x}_j}{\\partial t}\\mathbb{E}\\{P_j^2\\} &= -\\sum_{k=0}^{6}\\hat{x}_k \\mathbb{E}\\{\\xi P_k P_j\\} + \\cos(4t) \\mathbb{E}\\{P_j\\} \\\\\n",
                "\\frac{\\partial \\hat{x}_j}{\\partial t} &= -\\frac{1}{\\mathbb{E}\\{P_j^2\\}}\\sum_{k=0}^{6}\\hat{x}_k \\mathbb{E}\\{\\xi P_k P_j\\} + \\frac{\\cos(4t) \\mathbb{E}\\{P_j\\}}{\\mathbb{E}\\{P_j^2\\}} \\\\\n",
                "\\end{align}\n",
                "\n",
                "Recall from Question 1, Part A where we calculated the $P_1(\\xi)$\n",
                "\n",
                "\\begin{align}\n",
                "P_1(\\xi) &= \\xi + \\frac{2}{e^2 + 1} \\\\\n",
                "\\xi &= P_1(\\xi) - \\frac{2}{e^2 + 1}\n",
                "\\end{align}\n",
                "\n",
                "Plugging $\\xi$ back into the ODE we have:\n",
                "\n",
                "\\begin{align}\n",
                "\\frac{\\partial \\hat{x}_j}{\\partial t} &= -\\frac{1}{\\mathbb{E}\\{P_j^2\\}}\\sum_{k=0}^{6}\\hat{x}_k \\mathbb{E}\\{ \\left(P_1(\\xi) - \\frac{2}{e^2 + 1}\\right) P_k P_j\\} + \\frac{\\cos(4t) \\mathbb{E}\\{P_j\\}}{\\mathbb{E}\\{P_j^2\\}} \\\\\n",
                "\\frac{\\partial \\hat{x}_j}{\\partial t} &= -\\frac{1}{ \\mathbb{E}\\{P_j^2\\}} \\sum_{k=0}^{6}\\hat{x}_k \\mathbb{E}\\{P_1 P_k P_j\\} + \\frac{2\\hat{x}}{e^2 + 1} + \\frac{\\cos(4t) \\mathbb{E}\\{P_j\\}}{ \\mathbb{E}\\{P_j^2\\}}\n",
                "\\end{align}\n",
                "\n",
                "where the initial conditions are:\n",
                "\n",
                "\\begin{align}\n",
                "x(0;\\omega) &= 1 \\\\\n",
                "x(j;\\omega) &= 0 \\quad \\text{for } j = 1, ..., 6\n",
                "\\end{align}\n",
                "\n",
                "\n",
                "In the following code we precompute the expectations required for defining the first order system of equations, solve the IVP using Tsitouras 5/4 Runge-Kutta method, calculate the variance by the following:\n",
                "\n",
                "\\begin{align}\n",
                "var(x(t;\\omega)) = \\sum_{k=1}^{6}\\hat{x}_k^2(t) \\mathbb{E}\\{P_k^2\\}\n",
                "\\end{align}\n",
                "\n",
                "and plot the mean and variance on two seperate graphs in the temporal domain [0, 3]"
            ]
        },
        {
            "id": "16",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "using DifferentialEquations\n",
                "function question3a()\n",
                "    # get polynomials\n",
                "    πn = stieltjes(μ, 6, sup)\n",
                "\n",
                "    # simulation initial and final time\n",
                "    t0, tf = SVector{2}(0.0, 3.0)\n",
                "\n",
                "    # initial conditions\n",
                "    u0 = SVector{7}(1, 0, 0, 0, 0, 0, 0)\n",
                "\n",
                "    # highest polynomial order\n",
                "    M = size(πn)[1] - 1\n",
                "\n",
                "    # precompute E{Pj}\n",
                "    Epj1 = Vector{Float64}(undef, M)\n",
                "    for k in eachindex(Epj1)\n",
                "        Epj1[k] = integ(x -> πn[k+1](x) * μ(x), sup)\n",
                "    end\n",
                "\n",
                "    # precompute E{Pj^2}\n",
                "    Epj2 = Vector{Float64}(undef, M)\n",
                "    for j in eachindex(Epj2)\n",
                "            Epj2[j] = integ(x -> πn[j+1](x) * πn[j+1](x) * μ(x), sup)\n",
                "    end\n",
                "\n",
                "    # precompute E{P₁PkPj}\n",
                "    Ep1pjpk = Matrix{Float64}(undef, M, M)\n",
                "    for idx in CartesianIndices(Ep1pjpk)\n",
                "        (j, k) = idx.I\n",
                "        Ep1pjpk[j, k] = integ(x -> πn[2](x) * πn[j+1](x) * πn[k](x) * μ(x), sup)\n",
                "    end\n",
                "\n",
                "    # precompute the constant multiplying xhatj\n",
                "    β = (2.0 / (exp(1.0)^2 + 1.0))\n",
                "\n",
                "    # define the system of odes\n",
                "    function ode(u, p, t)\n",
                "        return SVector{M}(\n",
                "            ((-sum(u[k] * Ep1pjpk[j, k] for k in 1:M))/Epj2[j]) + β*u[j] + (cos(4*t)*Epj1[j]/Epj2[j]) for j in 1:M\n",
                "        )\n",
                "    end\n",
                "\n",
                "    # solve the ode problem using Tsitouras 5/4 Runge-Kutta method\n",
                "    prob = ODEProblem(ode, u0, (t0, tf))\n",
                "    sol = solve(prob, Tsit5(), saveat=0.01, abstol=1e-8, reltol=1e-8)\n",
                "    # find the variance\n",
                "    var = sum([(sol[k, :].^2) .* Epj2[k] for k in 2:M], dims=1)[1]\n",
                "\n",
                "    # plot the mean and variance\n",
                "    fig = Figure(size = (800, 400));display(fig)\n",
                "    ax1 = Axis(fig[1, 1], title = \"mean of x(t;ω)\",\n",
                "        xlabel = \"time\")\n",
                "    ax2 = Axis(fig[1, 2], title = \"variance of x(t;ω)\",\n",
                "        xlabel = \"time\")\n",
                "    lines!(ax1, sol.t, sol[1, :])\n",
                "    lines!(ax2, sol.t, var)\n",
                "    save(\"question3a.png\", fig)\n",
                "    return sol\n",
                "end\n",
                "question3a();"
            ],
            "outputs": [
                {
                    "output_type": "stream",
                    "name": "stdout",
                    "text": "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils ~/.julia/packages/PlotUtils/dVEMd/src/ticks.jl:194\u001b[39m\n\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils ~/.julia/packages/PlotUtils/dVEMd/src/ticks.jl:194\u001b[39m\n\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils ~/.julia/packages/PlotUtils/dVEMd/src/ticks.jl:194\u001b[39m\n"
                }
            ],
            "execution_count": 1
        },
        {
            "id": "17",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "![The mean and variance of \\eqref{eight} in $t \\in [0, 3]$](question3a.png)\n",
                "\n",
                "## Part B\n",
                "\n",
                "Compute the PDF of \\eqref{eight} at times $\\{0.5, 1, 2, 3\\}$ (use relative frequencies).\n",
                "\n",
                "Note: you can debug your gPC results by either computing the analytic solution of \\eqref{randomivp} and then computing moments/PDFs of such solutions as a function of $t$, or by randomly sampling many solution paths of \\eqref{randomivp} and then computing ensemble averages.\n",
                "\n",
                "### Solution\n",
                "\n",
                "We have everything we need to compute the PDF of \\eqref{eight} for various times.\n",
                "\n",
                "Let us generate a random vector by sampling $p_{\\xi}(x)$ 50,000 times, then generate samples by evaluating the following:\n",
                "\n",
                "\\begin{align}\n",
                "x(t^*;\\omega) = \\sum_{i=0}^{6}\\hat{x}_i(t^*) P_i(\\xi(\\omega))\n",
                "\\end{align}\n",
                "\n",
                "where\n",
                "\n",
                "\\begin{align}\n",
                "&\\hat{x}_i(t^*) &\\quad &\\text{are the gPC coefficients at time } t^* \\\\\n",
                "&P_i(\\xi) &\\quad &\\text{are the gPC basis functions} \\\\\n",
                "&\\xi &\\quad &\\text{random variables from the distribution } P_{\\xi}(x)\n",
                "\\end{align}"
            ]
        },
        {
            "id": "18",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "function question3b()\n",
                "    # get orthogonal polynomials\n",
                "    πn = stieltjes(μ, 6, sup)\n",
                "\n",
                "    # get gPC modes\n",
                "    sol = question3a()\n",
                "\n",
                "    # generate samples of ξ\n",
                "    r = LinRange(-1, 1, 1000)\n",
                "    ys = hcat(cumsumtrap(μ, r), r)\n",
                "    ξ_samples = Vector{Float64}(undef, 50000)\n",
                "    for i in eachindex(ξ_samples)\n",
                "        ξ_samples[i] = sampleInverseCDF(rand(), ys)\n",
                "    end\n",
                "\n",
                "    # define t*\n",
                "    times = SVector{4}(0.5, 1.0, 2.0, 3.0)\n",
                "\n",
                "    # number of solutions (gPC modes)\n",
                "    M = size(sol)[1]\n",
                "\n",
                "    # define figure\n",
                "    fig = Figure(size = (800, 800))\n",
                "    ax = SVector{4}(Axis(fig[1, 1]), Axis(fig[1, 2]), Axis(fig[2, 1]), Axis(fig[2, 2]))\n",
                "\n",
                "    # plot histogram of samples of x(tstar;ω)\n",
                "    for (i, tstar) in enumerate(times)\n",
                "        hist!(ax[i], sum(sol(tstar)[j] .* πn[j].(ξ_samples) for j in 1:M), bins = 80, normalization = :pdf)\n",
                "        ax[i].title = \"t = $tstar\"\n",
                "        ax[i].ylabel = \"normalized frequency\"\n",
                "    end\n",
                "    Label(fig[0, :], \"PDF of various times, for x(t;ω)\", fontsize=20)\n",
                "    save(\"question3b.png\", fig)\n",
                "end\n",
                "question3b();"
            ],
            "outputs": [
                {
                    "output_type": "stream",
                    "name": "stdout",
                    "text": "\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils ~/.julia/packages/PlotUtils/dVEMd/src/ticks.jl:194\u001b[39m\n\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mNo strict ticks found\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ PlotUtils ~/.julia/packages/PlotUtils/dVEMd/src/ticks.jl:194\u001b[39m\n"
                }
            ],
            "execution_count": 1
        },
        {
            "id": "19",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "![PDF for various times found by the method of relative frequencies](question3b.png)\n",
                "\n",
                "# Appendix\n",
                "\n",
                "## Validation\n",
                "\n",
                "Let us randomly sample many solution paths of \\eqref{randomivp} and then compute the ensemble average to validate our gPC results.\n",
                "\n",
                "For this we will generate 50,000 samples from the PDF of \\eqref{eq-pxi}, then solve the ODE numerically 50,000 times and plot the histogram of the normalized frequency just as we did in Question 3 partb."
            ]
        },
        {
            "id": "20",
            "cell_type": "code",
            "metadata": {
            },
            "source": [
                "function validation(N::Int64)\n",
                "    # generate samples of ξ\n",
                "    r = LinRange(-1, 1, 1000)\n",
                "    ys = hcat(cumsumtrap(μ, r), r)\n",
                "    ξ_samples = Vector{Float64}(undef, N)\n",
                "    for i in eachindex(ξ_samples)\n",
                "        ξ_samples[i] = sampleInverseCDF(rand(), ys)\n",
                "    end\n",
                "\n",
                "    # define t*\n",
                "    times = SVector{4}(0.5, 1.0, 2.0, 3.0)\n",
                "\n",
                "    # define the ODEProblem\n",
                "    function ode(u, p, t)\n",
                "    \treturn SVector{1}(-p * u[1] + cos(4*t))\n",
                "    end\n",
                "\n",
                "    # initial condition\n",
                "    u0 = SVector{1}(1)\n",
                "\n",
                "    # solve once to get size of time vector\n",
                "    prob = ODEProblem(ode, u0, (0.0, 3.0), -1.0)\n",
                "    sol = solve(prob, Tsit5(), saveat=0.01, abstol=1e-8, reltol=1e-8)\n",
                "\n",
                "    # init matrix to store solutions\n",
                "    solTstar = [Float64[] for _ in 1:length(times)]\n",
                "    solutions = Matrix{Float64}(undef, N, size(sol.t)[1])\n",
                "\n",
                "    # solve the ode for each sample and extract sample paths\n",
                "    for (i, ξ) in enumerate(ξ_samples)\n",
                "        prob = ODEProblem(ode, u0, (0.0, 3.0), ξ)\n",
                "        sol = solve(prob, Tsit5(), saveat=0.01, abstol=1e-8, reltol=1e-8)\n",
                "        solutions[i, :] = Float64[u[1] for u in sol.u]\n",
                "        for (j, tstar) in enumerate(times)\n",
                "            push!(solTstar[j], sol(tstar)[1])\n",
                "        end\n",
                "    end\n",
                "\n",
                "    # calculate sample path mean and variance\n",
                "    meanPath = mean(solutions, dims=1)\n",
                "    variancePath = var(solutions, mean=meanPath, dims=1)\n",
                "\n",
                "    # plot results\n",
                "    fig1 = Figure(size = (800, 800))\n",
                "    ax1 = [Axis(fig1[i, j]) for i in 1:2, j in 1:2]\n",
                "    fig2 = Figure(size = (800, 400))\n",
                "    ax2 = [Axis(fig2[1, i]) for i in 1:2]\n",
                "    for (i, tstar) in enumerate(times)\n",
                "        hist!(ax1[i], solTstar[i], bins = 80, normalization = :pdf)\n",
                "        ax1[i].title = \"t = $tstar\"\n",
                "        ax1[i].ylabel = \"Normalized Frequency\"\n",
                "    end\n",
                "    Label(fig1[0, :], \"PDF of Various Times Using MC Method\", fontsize=20)\n",
                "    lines!(ax2[1], sol.t, vec(meanPath), label=\"Mean Path\")\n",
                "    ax2[1].title = \"Mean Path\"\n",
                "    ax2[1].xlabel = \"Time\"\n",
                "    lines!(ax2[2], sol.t, vec(variancePath), label=\"Variance\")\n",
                "    ax2[2].title = \"Variance over Time\"\n",
                "    ax2[2].xlabel = \"Time\"\n",
                "    save(\"validationPDF.png\", fig1)\n",
                "    save(\"validationmeanvar.png\", fig2)\n",
                "end\n",
                "validation(50000);"
            ],
            "outputs": [
            ],
            "execution_count": 1
        },
        {
            "id": "21",
            "cell_type": "markdown",
            "metadata": {
            },
            "source": [
                "\n",
                "![The mean and variance of $x(t;\\omega)$ using Monte Carlo method](validationmeanvar.png)\n",
                "\n",
                "![The PDF for specific times using Monte Carlo method](validationPDF.png)\n",
                "\n",
                "## Figures\n",
                "\n",
                "![The PDF of $\\xi$](PDFone.png){#fig-pdfxi}"
            ]
        }
    ],
    "timestamp": "2025-07-07T11:55:53.311",
    "file": "/home/kevinsilberberg/Repos/paxnomada/courses/uncertainty_quant/docs/hw5/hw5.qmd",
    "qnr_schema_version": "1.0.0"
}